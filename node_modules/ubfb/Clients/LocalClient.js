const EventEmitter = require('events');
const Fetch = require('../Utils/Fetch');
const fs = require('fs');
const ms = require('ms');
const path = require('path');
const UbfbError = require('../Utils/UbfbError');
const { getAllLocalUsers, localSearch, getAllLocalLinks } = require('../Utils/GlobalFunctions');
const Users = require('../Utils/Users');

const DefaultConfig = {
    Installation: {
        MaxDownloads: Infinity,
        EachTime: '1day',
        InstallDeletedUsersLocally: false,
        DeletedUsers: [],
        InstallDeletedLinksLocally: false,
        DeletedLinks: []
    },
    Functions: {
        autoConvertJSON: true,
        autoConvertBuffers: true
    }
};

class ClientEvents extends EventEmitter {
    constructor() {
        super();

        this.version = 400;

        this.on('ready', () => {});
        this.addListener('ready', () => {});
    }
};

class Client {
    constructor(Config = DefaultConfig) {
        this.Emitter = new ClientEvents();

        (async () => {
            if(!Config) Config = DefaultConfig;

            if(!Config.Installation || typeof Config.Installation != 'object') Config.Installation = {};
            if(!Config.Installation.MaxDownloads || typeof Config.Installation.MaxDownloads != 'number') Config.Installation.MaxDownloads = Infinity;
            if(!Config.Installation.MaxCache || typeof Config.Installation.MaxCache != 'number') Config.Installation.MaxCache = Infinity;
            if(!Config.Installation.EachTime || typeof Config.Installation.EachTime != 'number') Config.Installation.EachTime = '1d';
            if(!Config.Installation.InstallDeletedUsersLocally || typeof Config.Installation.InstallDeletedUsersLocally != 'number') Config.Installation.InstallDeletedUsersLocally = false;
            if(!Config.Installation.DeletedUsers || typeof Config.Installation.DeletedUsers != 'number') Config.Installation.DeletedUsers = [];
            if(!Config.Installation.InstallDeletedLinksLocally || typeof Config.Installation.InstallDeletedLinksLocally != 'number') Config.Installation.InstallDeletedLinksLocally = [];
            if(!Config.Installation.DeletedLinks || typeof Config.Installation.DeletedLinks != 'number') Config.Installation.DeletedLinks = [];
            if(!Config.Functions || typeof Config.Functions != 'object') Config.Functions = {};
            if(!Config.Functions.autoConvertJSON || typeof Config.Functions.autoConvertJSON != 'boolean') Config.Functions.autoConvertJSON = true;
            if(!Config.Functions.autoConvertBuffers || typeof Config.Functions.autoConvertBuffers != 'boolean') Config.Functions.autoConvertBuffers = true;

            this.config = Config;

            this.InstallUsers = async () => {
                try{
                    fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Users'));
                }catch(err) {
                    fs.mkdirSync(path.join(__dirname, '../Cache/Malicious/Users'));
                }

                (require('../Cache/MaliciousDeleted/users.json').users).forEach(User => {
                    Config.Installation.DeletedUsers.push(User.userId);
                });

                fs.readdir(path.join(__dirname, '../Cache/Malicious/Users/'), async function (err, files) {
                    if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/Malicious/Users/')}'.\n` + err);

                    for(let Doc of (await Fetch.get('users/getAll')).search) {
                        if(!(Config.Installation.DeletedUsers.includes(Doc.userId) && Config.Installation.InstallDeletedUsersLocally) && (await fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Users/'))).length < Config.Installation.MaxDownloads && Config.Installation.DeletedUsers.includes(Doc.userId))return;
                        
                        try{
                            await fs.readFileSync(path.join(__dirname, `../Cache/Malicious/Users/${Doc.userId}.json`));
                        }catch(err) {
                            new Users.MaliciousUser(Doc, false).save();
                        }
                    };
                });
            };

            this.UninstallUsers = async () => {
                try{
                    fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Users'));
                }catch(err) {
                    fs.mkdirSync(path.join(__dirname, '../Cache/Malicious/Users'));
                }

                fs.readdir(path.join(__dirname, '../Cache/Malicious/Users/'), async function (err, files) {
                    if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/Malicious/Users/')}'.\n` + err);

                    for(let File of files) {
                        try{
                            await fs.readFileSync(path.join(__dirname, `../Cache/Malicious/Users/${File}`));
                            await fs.unlinkSync(path.join(__dirname, `../Cache/Malicious/Users/${File}`));
                        }catch(err) {}
                    };
                });
            };

            this.InstallLinks = async () => {
                try{
                    fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Links'));
                }catch(err) {
                    fs.mkdirSync(path.join(__dirname, '../Cache/Malicious/Links'));
                }

                (require('../Cache/MaliciousDeleted/links.json').links).forEach(Link => {
                    Config.Installation.DeletedLinks.push(Link.domain);
                });
                
                fs.readdir(path.join(__dirname, '../Cache/Malicious/Links/'), async function (err, files) {
                    if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/Malicious/Links/')}'.\n` + err);
                    
                    for(let Doc of (await Fetch.get('links/getAll')).search) {
                        if(Doc.domain.includes('/')) Doc.domain = Doc.domain.split('/').join('_');
                        if(!(Config.Installation.DeletedLinks.includes(Doc.domain) && Config.Installation.InstallDeletedLinksLocally) && (await fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Links/'))).length < Config.Installation.MaxDownloads && Config.Installation.DeletedLinks.includes(Doc.domain))return;

                        try{
                            await fs.readFileSync(path.join(__dirname, `../Cache/Malicious/Links/${Doc.domain}.json`));
                        }catch(err) {
                            new Users.MaliciousLink(Doc, false).save();
                        }
                    };
                });
            };

            this.UninstallLinks = async () => {
            try{
                fs.readdirSync(path.join(__dirname, '../Cache/Malicious/Links'));
            }catch(err) {
                fs.mkdirSync(path.join(__dirname, '../Cache/Malicious/Links'));
            }

                fs.readdir(path.join(__dirname, '../Cache/Malicious/Links/'), async function (err, files) {
                    if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/Malicious/Links/')}'.\n` + err);

                    for(let File of files) {
                        try{
                            await fs.readFileSync(path.join(__dirname, `../Cache/Malicious/Links/${File}`));
                            await fs.unlinkSync(path.join(__dirname, `../Cache/Malicious/Links/${File}`));
                        }catch(err) {}
                    };
                });
            };

            this.InstallUsers();
            setTimeout(() => {
                this.Emitter.emit('ready', {
                    Client: {
                        ClientConfig: Config,
                        thisObject: this,
                        Emitter: this.Emitter
                    },
                    Emitter: this.Emitter,
                    users: module.exports.users,
                    links: module.exports.links,
                    Fetch: Fetch
                });

                this.InstallLinks();
            }, 5000);

            setInterval(() => {
                this.InstallUsers();
                this.InstallLinks();
            }, ms(Config.Installation.EachTime));
        })();
    }

    on(event, callback) {
        this.Emitter.on(event, Object => callback(Object));
    }
}

module.exports = {
    Client,
    users: {
        getAll: async () => {
            return await getAllLocalUsers(this.config);
        },
        getId: async (userId) => {
            return await localSearch('userId', userId, this.config);
        },
        search: async (value, content) => {
            return await localSearch(value, content, this.config);
        },
        delete: async (userId, saveDeleted = true) => {
            fs.unlinkSync(path.join(__dirname, `../Cache/Malicious/Users/${userId}.json`));

            if(saveDeleted) fs.readdir(path.join(__dirname, '../Cache/MaliciousDeleted/'), async function (err, files) {
                if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/MaliciousDeleted/')}'.\n` + err);

                let cache = require('../Cache/MaliciousDeleted/users.json');
                if(cache.users.includes(userId))return;
                cache.users.push(userId);
                fs.writeFileSync(path.join(__dirname, `../Cache/MaliciousDeleted/users.json`), JSON.stringify(cache), () => {});
            });
        },
        create: (userId, reason, ...proofs) => {
            let newUser = new Users.MaliciousUser({ userId: userId, reason: reason, proofs: proofs });
            newUser.save();

            return newUser;
        }
    },
    links: {
        getAll: async () => {
            return await getAllLocalLinks(this.config);
        },
        getDomain: async (domain) => {
            return await localSearch('domain', domain, this.config, false);
        },
        search: async (value, content) => {
            return await localSearch(value, content, this.config, false);
        },
        delete: async (domain, saveDeleted = true) => {
            fs.unlinkSync(path.join(__dirname, `../Cache/Malicious/Links/${domain.split('/').join('_')}.json`));

            if(saveDeleted) fs.readdir(path.join(__dirname, '../Cache/MaliciousDeleted/'), async function (err, files) {
                if(err)return UbfbError(`No se pudo escanear una ruta '${path.join(__dirname, '../Cache/MaliciousDeleted/')}'.\n` + err);

                let cache = require('../Cache/MaliciousDeleted/links.json');
                if(cache.links.includes(domain))return;
                cache.links.push(domain);
                fs.writeFileSync(path.join(__dirname, `../Cache/MaliciousDeleted/links.json`), JSON.stringify(cache), () => {});
            });
        },
        create: (domain, isMalicious, typef) => {
            let newLink = new Users.MaliciousLink({ domain: domain, isMalicious: isMalicious, typef: typef });
            newLink.save();

            return newLink;
        }
    }
}