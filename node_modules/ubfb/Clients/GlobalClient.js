const WebSocketClient = require('websocket').client;
const sockets = new WebSocketClient();
const EventEmitter = require('events');
const Fetch = require('../Utils/Fetch');
const UbfbError = require('../Utils/UbfbError');
const { globalSearch } = require('../Utils/GlobalFunctions');
const config = require('../config.json');
const cacheger = require('cacheger');
const cache = { users: new cacheger('users'), links: new cacheger('links') };

const DefaultConfig = {
    Functions: {
        autoConvertJSON: true,
        autoConvertBuffers: true
    },
    Connection: {
        Anonymous: true,
        ClientId: null,
        ClientTag: null,
        ClientGuilds: null
    }
};

class ClientEvents extends EventEmitter {
    constructor() {
        super();

        this.version = 400;

        this.on('ready', () => {});
        this.on('connectionCreate', () => {});
        this.on('connectionDelete', () => {});
        this.on('linkCreate', (body) => {
            cache.links.set(body.link.domain, body.link);
        });
        this.on('linkDelete', (body) => {
            cache.links.delete(body.link.domain, body.link);
        });
        this.on('linkUpdate', (body) => {
            cache.links.set(body.link.domain, body.link);
        });
        this.on('maliciousCreate', (body) => {
            cache.users.set(body.user.userId, body.user);
        });
        this.on('maliciousDelete', (body) => {
            cache.users.delete(body.user.userId, body.user);
        });
        this.on('maliciousUpdate', (body) => {
            cache.users.set(body.user.userId, body.user);
        });
        this.on('newVote', () => {});
        this.on('ratelimit', () => {});
        this.on('reportCreate', () => {});
        this.on('reportDelete', () => {});
        this.addListener('ready', () => {});
        this.addListener('connectionCreate', () => {});
        this.addListener('connectionDelete', () => {});
        this.addListener('linkCreate', () => {});
        this.addListener('linkDelete', () => {});
        this.addListener('linkUpdate', () => {});
        this.addListener('maliciousCreate', () => {});
        this.addListener('maliciousDelete', () => {});
        this.addListener('maliciousUpdate', () => {});
        this.addListener('newVote', () => {});
        this.addListener('ratelimit', () => {});
        this.addListener('reportCreate', () => {});
        this.addListener('reportDelete', () => {});
    }
};

class Client {
    constructor(UbfbToken = 'PUBLIC', Config = DefaultConfig) {
        this.Emitter = new ClientEvents();

        if(!UbfbToken) UbfbError('No hay token establecido.');
        if(!Config) Config = DefaultConfig;
        if(!Config.Functions || typeof Config.Functions != 'object') Config.Functions = {};
        if(!Config.Functions.autoConvertJSON || typeof Config.Functions.autoConvertJSON != 'boolean') Config.Functions.autoConvertJSON = true;
        if(!Config.Functions.autoConvertBuffers || typeof Config.Functions.autoConvertBuffers != 'boolean') Config.Functions.autoConvertBuffers = true;
        if(!Config.Connection || typeof Config.Connection != 'object') Config.Connection = {};
        if(!Config.Connection || typeof Config.Connection.Anonymous != 'boolean') Config.Connection.Anonymous = true;
        if(!Config.Connection || typeof Config.Connection.ClientId != 'string') Config.Connection.ClientId = null;
        if(!Config.Connection || typeof Config.Connection.ClientTag != 'string') Config.Connection.ClientTag = null;
        if(!Config.Connection || typeof Config.Connection.ClientGuilds != 'number') Config.Connection.ClientGuilds = null;

        this.config = Config;
        Fetch.token = UbfbToken;

        this.getAllUsers(false).then(Users => Users.map(User => cache.users.set(User.userId, User)));
        this.getAllLinks(false).then(Links => Links.map(Link => cache.links.set(Link.domain, Link)));

        sockets.on('connectFailed', (error) => {
            console.error('Error al conectar con UBFB: ' + error.toString());
        });

        sockets.on('connect', async (connection) => {
            connection.sendReadableUTF = (body) => {
                if(typeof body != 'string') body.client = {
                    token: UbfbToken,
                    anonymous: Config.Connection.Anonymous,
                    id: Config.Connection.ClientId,
                    tag: Config.Connection.ClientTag,
                    guilds: Config.Connection.ClientGuilds
                };

                connection.sendUTF(JSON.stringify(body));
            };

            this.connection = connection;
            this.readyAt = Date.now();

            connection.sendReadableUTF({
                event: {
                    type: 'connect'
                },
                callback: UbfbToken
            });

            connection.on('message', async (message) => {
                message = JSON.parse(message.utf8Data);
                if(message.failed || (message.callback && UbfbToken != message.callback)) UbfbError('API MESSAGE: ' + message.message);
                if(message.message && message.message.includes('WS Conectado a UBFB'))return this.Emitter.emit('ready', this);

                if(message.event === 'new:connection') this.Emitter.emit('connectionCreate', message.body);
                else if(message.event === 'new:disconnect') this.Emitter.emit('connectionDelete', message.body);
                else if(message.event === 'create:link') this.Emitter.emit('linkCreate', message.body);
                else if(message.event === 'delete:link') this.Emitter.emit('linkDelete', message.body);
                else if(message.event === 'update:link') this.Emitter.emit('linkUpdate', message.body);
                else if(message.event === 'create:malicious') this.Emitter.emit('maliciousCreate', message.body);
                else if(message.event === 'delete:malicious') this.Emitter.emit('maliciousDelete', message.body);
                else if(message.event === 'update:malicious') this.Emitter.emit('maliciousUpdate', message.body);
                else if(message.event === 'new:vote') this.Emitter.emit('newVote', message.body);
                else if(message.event === 'add:ratelimit') this.Emitter.emit('ratelimit', message.body);
                else if(message.event === 'create:report') this.Emitter.emit('reportCreate', message.body);
                else if(message.event === 'delete:report') this.Emitter.emit('reportDelete', message.body);
            });
        });

        sockets.connect(`ws://${config.ApiIp}:${config.port}/`, 'echo-protocol');
    }

    on(event, callback) {
        this.Emitter.on(event, Object => callback(Object));
    }

    async getConnections(id = 'all') {
        return await Fetch.get('connections/' + id);
    }

    async getUser(Identificator) {
        if(cache.users.has(Identificator))return cache.users.get(Identificator);
        else {
            let response = await Fetch.get('users/search/userId/' + Identificator);
            if(response.search[0]) cache.users.set(Identificator, response.search[0]);

            return response.search[0];
        };
    }

    async getAllUsers(fromCache = true) {
        if(fromCache)return Array.from(cache.users[cache.users.cacheName].values());
        let users = (await Fetch.get('users/getall')).search;
        users.map(User => cache.users.set(User.userId, User));

        return users;
    }

    async reportUser(reportData = {
        userId: String,
        reason: String,
        mainProof: String,
        moreProofs: Array,
        reportedBy: {
            anonymous: Boolean,
            authorTag: String,
            authorId: String
        }
    }) {
        if(!reportData) reportData = {};
        if(!reportData.userId) reportData.userId = String;
        if(!reportData.reason) reportData.reason = String;
        if(!reportData.mainProof) reportData.mainProof = String;
        if(!reportData.moreProofs) reportData.moreProofs = Array;
        if(!reportData.reportedBy) reportData.reportedBy = {};
        if(!reportData.reportedBy.anonymous && typeof reportData.reportedBy.anonymous != 'boolean') reportData.reportedBy.anonymous = Boolean;
        if(!reportData.reportedBy.authorTag) reportData.reportedBy.authorTag = String;
        if(!reportData.reportedBy.authorId) reportData.reportedBy.authorId = String;

        if(Array.from(Object.entries(reportData)).map(x => x[x.indexOf(x, 1)] = typeof x[1]).map(y => y.includes('function')).includes(true)) UbfbError('El reporte debe ser enviado al completo.');
        if(!config.maliciousReasons.includes(reportData.reason)) UbfbError('Las razones de reportes de usuarios maliciosos son las siguientes:\n' + config.maliciousReasons.join(', '));
        if(!reportData.mainProof.startsWith('http') || reportData.moreProofs.map(Proof => Proof.startsWith('http')).includes(false)) UbfbError('Los reportes deben ser enlaces.');

        return await (Fetch.post('users/report', {
            userId: reportData.userId,
            proof: reportData.mainProof,
            proofs: reportData.moreProofs,
            reason: reportData.reason,
            by: {
                anonymous: reportData.reportedBy.anonymous,
                tag: reportData.reportedBy.authorTag,
                id: reportData.reportedBy.authorId
            }
        }));
    }

    async searchUser(value, content) {
        return await globalSearch(value, content);
    }

    async getLink(Domain) {
        if(cache.links.has(Domain))return cache.links.get(Domain);
        else {
            let response = await Fetch.get('links/search/domain/' + Domain);
            if(response.search[0]) cache.links.set(Domain, response.search[0]);

            return response.search[0];
        };
    }

    async getAllLinks(fromCache = true) {
        if(fromCache)return Array.from(cache.links[cache.links.cacheName].values());
        let links = (await Fetch.get('links/getall')).search;
        links.map(Link => cache.links.set(Link.domain, Link));

        return links;
    }

    async reportLink(reportData = {
        domain: String,
        reportedBy: {
            anonymous: Boolean,
            authorTag: String,
            authorId: String
        }
    }) {
        if(!reportData) reportData = {};
        if(!reportData.domain) reportData.domain = String;
        if(!reportData.reportedBy) reportData.reportedBy = {};
        if(!reportData.reportedBy.anonymous && typeof reportData.reportedBy.anonymous != 'boolean') reportData.reportedBy.anonymous = Boolean;
        if(!reportData.reportedBy.authorTag) reportData.reportedBy.authorTag = String;
        if(!reportData.reportedBy.authorId) reportData.reportedBy.authorId = String;

        if(Array.from(Object.entries(reportData)).map(x => x[x.indexOf(x, 1)] = typeof x[1]).map(y => y.includes('function')).includes(true)) UbfbError('El reporte debe ser enviado al completo.');

        return await (Fetch.post('links/report', {
            domain: reportData.domain,
            by: {
                anonymous: reportData.reportedBy.anonymous,
                tag: reportData.reportedBy.authorTag,
                id: reportData.reportedBy.authorId
            }
        }));
    }

    async searchLink(value, content) {
        return await globalSearch(value, content, false);
    }

    DecryptProof(Proof) {
        return Buffer.from(Proof, 'base64');
    }
}

module.exports = {
    Client,
}